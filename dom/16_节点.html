<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div id="div1">
        哈哈哈哈哈
    </div>
    <!-- jfgjsdgf -->
    <h2>hehehe</h2>
    <ul>
        <li>111</li>
        <li id="li2">222</li>
    </ul>
    <script>
        var oDiv1 = document.getElementById("div1");
        // console.log(oDiv1.nodeType)
        // console.log(oDiv1.nodeName)
        // console.log(oDiv1.firstChild.nodeName); //#text

        // 节点属性（遍历）

        /*  
            节点属性（遍历）
            oDiv1.nextSibling; //ie中 只支持nextSibling 直接找到下一个元素节点 ；标准浏览器中找到的是下一个文本节点（回车+空格）
            oDiv1.nextElementSibling //dom3语法  ie不支持 
            previousSibling  ie中直接找到上一个兄弟节点  标准浏览器下 会找到回车+空格
            previousElementSibling ie不支持

            firstChild 第一个孩子   ie直接找到第一个元素节点的孩子，标准浏览器中找到的是第一个孩子节点（可能是文本节点）
            firstElementChild
            lastChild 最后一个孩子
            lastElementChild 
            children 元素节点所有孩子 所有浏览器都支持

        */
        // 封装一个方法  返回下一个元素节点  当元素没有下一个兄弟节点的时候 ，返回null

        function next(elem){
            do{
                elem = elem.nextSibling;  
            }while(elem && elem.nodeType != 1)   
            //如果下一个（elem)的节点 不是null 并且类型不是元素节点，循环继续找
            return elem;
        }

        // console.log(oDiv1.nextSibling);  


        var oLi = document.getElementById("li2");
        // console.log(oLi.nextElementSibling);  //null

        console.log(  next(oLi)  );  

        // null undefined

        function prev(elem){
            do{
                elem = elem.previousSibling
            }while(elem && elem.nodeType != 1)
            return elem;
        }

        prev(oLi);

        // 找到第一个元素节点的孩子
        function first(){


        }
    </script>

</body>
</html>